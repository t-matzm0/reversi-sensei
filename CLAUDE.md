# Reversi Sensei 開発ガイドライン

このドキュメントは、Reversi Senseiプロジェクトの開発ルールと履歴を記録したものです。
Claude Codeを使用する際は、必ずこのドキュメントを参照して、プロジェクトの一貫性を保ってください。

## プロジェクト概要

Reversi Sensei（リバーシ先生）は、リバーシ（オセロ）の戦略を学ぶためのWebアプリケーションです。
Next.js、React、TypeScriptを使用して構築され、Firebase Hostingでホスティングされています。

## 開発履歴

### 2025年6月13日 - プロジェクト開始

- 初期プロジェクトセットアップ（Next.js + TypeScript）
- コアゲームロジックとAIの実装
- React UIコンポーネントの作成
- クロスプラットフォームデプロイメント設定
- 包括的なプロジェクトドキュメントの追加
- GitHub Actions CI/CDのセットアップ
- Firebase環境（ステージング/本番）のセットアップ

### 2025年6月14日

- リバーシ戦略チュートリアルの実装

### 2025年6月19日

- モジュラー構造によるゲームアーキテクチャの強化
- Jestテスティングフレームワークと初期テストスイートの追加

### 2025年6月20日

- CI/CDパイプラインの修正
- Firebaseプロジェクトの統合（マルチサイトホスティング）
- ステージングURLの更新
- 最後の手の表示バグ修正（#1）
- 手の評価表示機能の追加（#2, #8）
- 評価表示の即時更新問題の修正
- 序盤の手の評価正規化の改善

### 2025年6月26日

- コードフォーマットとテスト失敗の解決

### 2025年7月2日

【作業内容】

- CLAUDE.md（開発ガイドライン）の作成
- プロジェクトの開発履歴をコミットログから抽出
- コードベースから開発ルールとパターンを分析・文書化
- Git操作のベストプラクティスを追加（コミット粒度、静的テスト実行）
- 今後の開発予定セクションを追加
- GitHub Projects/Issuesとの使い分けを明確化
- GitHub Issuesに主要な機能要望を登録
  - #9: オンライン対戦機能の実装
  - #10: AIの強化
  - #11: 統計・分析機能の追加
  - #12: UI/UXの改善
  - #13: チュートリアルの拡充
- Markdownリンターの警告を修正

- Git Flow開発フローのルールを追加
- Issue #2（評価値表示機能）のクローズ確認と対応
- Issue #5（白背景に白文字のバグ）の調査と修正

  - `piece-white`色を#f0f0f0から#e0e0e0に変更
  - PR #15でバグ修正完了

- Issue #4（待った機能）の実装完了

  - ゲーム設定に`allowUndo`フラグを追加
  - useGameStateフックに履歴管理機能を実装
    - `addMoveToHistory`: 手の履歴を記録
    - `makeGameMove`: 手の実行と履歴追加を統合
    - `undoLastMove`: 最後の手を取り消す機能
  - GameInfoコンポーネントに待った設定トグルと実行ボタンを追加
  - Gameコンポーネントで新しいフック関数を統合
  - 全てのテストとビルドが正常に通過することを確認

- Issue #16（評価値が正確に計算されていない）の対応開始

  - 問題分析：AIが先読みを実装していない（depthの設定が使われていない）
  - ミニマックス法とアルファベータ剪定を実装
  - 評価関数の改善：
    - ゲーム終了時の正確な評価
    - モビリティ（有効手数）の考慮
    - ゲーム進行度に応じた評価の重み付け調整
  - 全てのテストが通過することを確認

- Issue管理のミス対応
  - Issue #4と#5を誤ってクローズしてしまったため再オープン
  - レビュー待ちのコメントを追加
  - CLAUDE.mdにIssue管理ルールを追加：
    - 作業開始前にIn Progressに設定する
    - 実装完了後も勝手にクローズしない
    - レビュー承認後のマージ時にクローズ

【次回への申し送り】

- PR #17のレビュー待ち（Issue #16: AI評価関数の改善）
- Issue #4と#5のレビュー待ち（developブランチの9745241で実装済み）
- AIのさらなる改善（安定石、辺の形、開放度などの実装）
- 待った機能のテストケース追加（低優先度）
- 次の新機能開発の検討（Issue #6のアニメーション機能など）

### 2025年7月3日

【作業内容】

- 開発環境の確認と文書化
  - 現在の開発環境: WSL2 (Windows Subsystem for Linux)
  - Node.js: v20.12.2 (Volta管理)
  - npm: 10.5.0
  - テスト環境の動作確認（Lint、Jest）完了

【開発環境情報】

本プロジェクトはクロスプラットフォーム対応で、以下のすべての環境で同等に開発可能：

1. **WSL2環境**

   - Windows上でLinux環境を使用
   - Node.js管理にVoltaを使用
   - VS Code Remote接続で開発

2. **ネイティブWindows環境**

   - Windows PowerShell/コマンドプロンプト
   - Node.jsの直接インストール

3. **Mac環境**
   - ターミナルで開発
   - HomebrewでNode.js管理も可

**環境確認コマンド：**

```bash
# OS確認
uname -a  # Linux/Mac
# または
systeminfo  # Windows

# Node.js/npmバージョン確認
node --version
npm --version

# テスト実行確認
npm run lint
npm test
```

【実装内容】

- WSL2環境でのテスト実行完了
  - Lint: ✅ エラー/警告なし
  - Test: ✅ 全41テスト合格（5テストスイート）
  - Build: ✅ 正常完了（静的サイト生成）
  - Format: ✅ コード整形完了
- 開発環境情報をCLAUDE.mdに文書化
- 現在の開発環境は正常に動作確認済み

【現在の状況】

- ブランチ: `feature/16-improve-ai-evaluation`
- 作業中のタスク: Issue #16（AI評価関数の改善）
- PR #17: レビュー待ち状態
- 開発環境: WSL2（Node.js v20.12.2, npm 10.5.0）
- テスト環境: 全て正常動作確認済み

【次回への申し送り】

- PR #17のレビュー状況確認（Issue #16: AI評価関数の改善）
- Issue #4と#5のレビュー状況確認（developブランチの9745241で実装済み）
- AIのさらなる改善検討（安定石、辺の形、開放度などの実装）
- 待った機能のテストケース追加（低優先度）
- 次の新機能開発の検討（Issue #6のアニメーション機能など）
- 開発環境に関わらず、必ずテストを実行してから作業を進める

### 2025年7月4日

【作業内容】

- 現在のプロジェクト状況の確認
  - ブランチ: `feature/16-improve-ai-evaluation`
  - PR #17: オープン状態（AI評価関数の改善 - ミニマックス法実装）
  - Issue #16: PR #17で対応中
  - Issue #4（待った機能）: コミット9745241で実装済み、レビュー待ち
  - Issue #5（白石の色）: PR #15で修正済み（#e0e0e0に変更）
- 評価値表示が手番視点に統一されていることを確認（コミット aad6ee0）
- CLAUDE.mdの開発作業記録更新ルールを修正
  - 「作業ごとに必ず記録を更新」に変更（日々ではなく、指示されたごとに）

【次回への申し送り】

- PR #17のレビュー・マージ待ち
- Issue #4と#5の状況確認（オーナーによるレビュー待ち）
- 次の開発タスクの選定：
  - Issue #6（アニメーション機能）の実装
  - AIのさらなる改善（安定石、辺の形、開放度などの実装）
  - 待った機能のテストケース追加（低優先度）
- 開発記録の更新を忘れずに行う

### 2025年7月8日

【作業内容】

- **開発サーバー起動問題の解決**

  - WSL環境で開発サーバーが起動してもアクセスできない問題を調査
  - 原因: WSL特有のネットワーキング問題（localhostバインディング）
  - 解決策: クロスプラットフォーム対応の開発サーバー起動スクリプトを作成

- **実装内容**

  - `scripts/dev.js`: 環境自動検出スクリプトを作成
    - WSL、Windows、Mac、Linuxを自動判別
    - WSL環境では`0.0.0.0`にバインドして外部アクセスを可能に
    - 各環境に応じた適切な設定で開発サーバーを起動
  - `package.json`: `npm run dev`コマンドを新しいスクリプトに変更
  - `.env.development`: WSL用の環境設定ファイルを追加

- **動作確認**
  - Lint: ✅ エラー/警告なし
  - Test: ✅ 全41テスト合格
  - Build: ✅ 正常完了

【開発サーバーの起動方法】

```bash
# 全環境共通（自動検出）
npm run dev

# 環境別の直接起動
npm run dev:local  # ローカル環境専用
npm run dev:wsl    # WSL環境専用（0.0.0.0バインド）
```

**アクセス方法:**

- WSL環境:
  - WSL内から: `http://localhost:3000`
  - Windows側から: `http://localhost:3000`
- Windows/Mac/Linux環境: `http://localhost:3000`

- **評価値表示の改善**

  1. **相対評価から絶対評価への変更**

  - 問題: 評価値100の手が実際には悪手になるケースが発生
  - 原因: 相対的な正規化（最低値を0、最高値を100にマッピング）
  - 解決: 絶対評価方式に変更
    - -100～100の絶対スケールを使用
    - ゲーム終了位置: ±100
    - 非常に強い位置: ±90
    - 通常の位置: -80～80の範囲
  - 色分けも更新:
    - 50以上: 濃い緑（非常に良い手）
    - 25～50: 緑（良い手）
    - 0～25: 青（やや良い手）
    - -25～0: オレンジ（やや悪い手）
    - -50～-25: 赤（悪い手）
    - -50未満: 濃い赤（非常に悪い手）

  1. **AIターン時の評価値非表示**
     - AIが考えている間は評価値表示が不要
     - `isVsComputer && currentPlayer === 'white'`の時はnullを渡して計算をスキップ
  1. **評価値の正確性向上**
     - `evaluateMove`関数をミニマックス法を使用するよう修正
     - AIが実際に使用する評価と同じ方法で計算
     - 難易度に応じた深さ：
       - Easy: ランダム性を含む単純評価
       - Medium: 深さ2のミニマックス
       - Hard: 深さ3のミニマックス

【次回への申し送り】

- PR #17のレビュー・マージ待ち（AI評価関数の改善）
- Issue #4と#5の状況確認（オーナーによるレビュー待ち）
- 開発サーバー起動の動作確認（各環境でテスト）
- 評価値表示の修正をPR #17に含めるか別PRにするか検討
- 次の開発タスクの選定：
  - Issue #6（アニメーション機能）の実装
  - AIのさらなる改善（安定石、辺の形、開放度などの実装）
  - 待った機能のテストケース追加（低優先度）

### 2025年7月9日

【作業内容】

- 適切な粒度でのコミット分割作業
  - WSL環境対応の開発サーバー起動スクリプト（scripts/dev.js、.env.development）をコミット
  - 評価値表示の改善（相対評価から絶対評価への変更）をコミット
  - CLAUDE.mdの7月3日と7月8日の開発記録をコミット

【実装内容】

1. **WSL環境対応コミット（c9b5b15）**

   - 環境自動検出スクリプト scripts/dev.js を追加
   - WSL環境では0.0.0.0にバインドして外部アクセスを可能に
   - .env.developmentでWSL用の環境設定を追加

2. **評価値表示改善コミット（f039a21）**

   - 相対評価(0-100)から絶対評価(-100～100)に変更
   - 色分けを6段階に細分化
   - evaluateMove関数をミニマックス法を使用するよう修正
   - AIターン時は評価値計算をスキップ

3. **ドキュメント更新コミット（8038f81）**
   - 7月3日の開発環境確認作業を記録
   - 7月8日のWSL対応と評価値改善作業を記録

【次回への申し送り】

- PR #17のレビュー・マージ待ち（AI評価関数の改善 + 今回の評価値表示改善）
- Issue #4と#5の状況確認（オーナーによるレビュー待ち）
- 開発サーバー起動の動作確認（各環境でテスト）
- 次の開発タスクの選定：
  - Issue #6（アニメーション機能）の実装
  - AIのさらなる改善（安定石、辺の形、開放度などの実装）
  - 待った機能のテストケース追加（低優先度）

### 開発作業記録の更新ルール

このセクションは**作業の記録と引き継ぎ**のために使用する：

1. **作業ごとに必ず記録を更新**

   - 指示された作業を完了するたびに記録を追加
   - 次回Claude Codeを起動した際にすぐに引き継げるように記載

2. **作業中**

   - 実装した内容を随時追記
   - 発生した問題や解決方法をメモ
   - 次回に持ち越すタスクを記録

3. **記録フォーマット**

   ```text
   ### YYYY年MM月DD日

   【作業予定】
   - タスク1
   - タスク2

   【実装内容】
   - 完了した作業の詳細
   - 変更したファイルと理由

   【次回への申し送り】
   - 未完了のタスク
   - 調査が必要な項目
   ```

### Claude Code起動時の確認ルール

Claude Codeを起動したら、**必ず以下を確認**してから作業を開始する：

1. **最新の開発記録を確認**

   - CLAUDE.mdの最新日付セクションを読む
   - 「【次回への申し送り】」の内容を把握
   - 進行中のPRやIssueの状況を確認

2. **現在の状況を把握**

   - 現在のブランチと作業内容を確認
   - 未完了のタスクがあるかチェック
   - レビュー待ちのPRがあるかチェック

3. **次のアクションを決定**

   - 「【次回への申し送り】」から適切なタスクを選択
   - 新しい指示がない場合は、記録された次の候補タスクを提案
   - 不明な場合は、現在の状況を報告して指示を求める

4. **作業内容の明確化**
   - 何をするべきか明確でない場合は、必ず確認を取る
   - 推測で作業を進めるのではなく、明確な指示を求める

**重要**: この確認を怠ると、過去の作業内容や進捗を見失い、重複作業や方向性の誤りが発生する可能性がある。

### GitHub Projects/Issuesとの使い分け

- **GitHub Issues**: 機能単位の大きなタスク管理（例：「オンライン対戦機能の実装」）
- **GitHub Projects**: プロジェクト全体の進捗管理とロードマップ
- **CLAUDE.md開発記録**: 日々の細かい作業メモと申し送り事項

## 開発ルール

### 1. 命名規則

#### コンポーネント

- **PascalCase**を使用（例：`GameBoard`, `GameInfo`）
- ファイル名はコンポーネント名と完全に一致させる
- 目的が明確にわかる説明的な名前を使用

#### 関数

- **camelCase**を使用
- アクション関数には動詞プレフィックスを付ける（例：`makeMove`, `createInitialBoard`）
- ブール値を返す関数は`is`で始める（例：`isValidMove`, `isGameOver`）
- イベントハンドラーは`handle`で始める（例：`handleCellClick`, `handleAIMove`）

#### 変数

- **camelCase**を使用
- 説明的な名前を使用（例：`currentPlayer`, `possibleMoves`）
- 定数は**UPPER_SNAKE_CASE**（例：`BOARD_SIZE`, `INITIAL_SCORES`）

#### ファイル

- TypeScript/JavaScriptファイルは**camelCase**
- コンポーネントファイルはコンポーネント名と一致
- ユーティリティ/ライブラリファイルは説明的な名前（例：`gameLogic.ts`, `board.ts`）

### 2. インポート順序

以下の順序でインポートを整理：

1. React/Next.js関連
2. サードパーティライブラリ
3. 内部コンポーネント（`@/components`）
4. 型定義（`@/types`）
5. カスタムフック（`@/hooks`）
6. ライブラリ（`@/lib`）
7. ユーティリティ（`@/utils`）
8. 定数（`@/constants`）

### 3. コミットメッセージ

**Conventional Commits**形式を使用：

- `feat:` 新機能
- `fix:` バグ修正
- `refactor:` リファクタリング
- `test:` テスト関連
- `docs:` ドキュメント更新
- `ci:` CI/CD関連
- `debug:` デバッグ用（マージ前に削除）

### 4. コード構造

#### コンポーネント構造

1. インターフェース定義
2. コンポーネント関数（propsの分割代入）
3. カスタムフックの使用
4. `useCallback`でイベントハンドラー定義
5. パフォーマンスクリティカルなコンポーネントは`React.memo`でメモ化
6. セマンティックHTMLとTailwind CSSクラスを使用したJSX

#### フック構造

1. インポート文
2. 状態とメソッドを含むオブジェクトを返すフック関数
3. 必要に応じて`useState`、`useCallback`、`useEffect`を使用
4. 関心の分離を明確に

### 5. テスト

- テストファイルは`src/__tests__/`ディレクトリに配置
- ファイル名：`[ComponentName].test.tsx`または`[moduleName].test.ts`
- React Testing Libraryを使用
- Arrange-Act-Assertパターンを使用
- 説明的なテスト名を使用

### 6. スタイリング

- Tailwind CSSを使用
- 一貫したスペーシングとカラースキーム
- レスポンシブデザイン（`md:`ブレークポイント）
- 日本語UIテキストを使用

### 7. TypeScript

- 厳格モードを有効化
- `any`型の使用禁止
- nullチェックの徹底
- コンポーネントpropsにはインターフェースを使用

### 8. エラーハンドリング

- ErrorBoundaryでコンポーネントをラップ
- ユーザーフレンドリーな日本語エラーメッセージ
- デバッグ用にコンソールにエラーログを出力
- 操作前にnull/undefinedチェック

### 9. パフォーマンス

- 高価な操作とコンポーネントはメモ化
- `'use client'`ディレクティブの適切な使用
- 必要に応じて`useCallback`と`useMemo`を使用

### 10. ファイル作成ルール

- **既存ファイルの編集を優先**する
- 新規ファイルは絶対に必要な場合のみ作成
- ドキュメントファイル（\*.md）は明示的に要求された場合のみ作成
- READMEファイルのプロアクティブな作成は禁止

### 11. Git操作

- コミットは明示的に要求された場合のみ実行
- プロアクティブなコミットは禁止
- git configの変更は禁止

## プロジェクト構造

```text
reversi_sensei/
├── src/
│   ├── app/              # Next.js App Routerページ
│   ├── components/       # Reactコンポーネント
│   ├── lib/              # ビジネスロジック
│   ├── hooks/            # カスタムフック
│   ├── types/            # TypeScript型定義
│   ├── constants/        # 定数
│   ├── utils/            # ユーティリティ関数
│   └── __tests__/        # テストファイル
├── public/               # 静的アセット
└── out/                  # ビルド出力
```

## 開発コマンド

- `npm run dev` - 開発サーバー起動
- `npm test` - テスト実行
- `npm run lint` - ESLint実行
- `npm run format` - Prettier実行
- `npm run build` - プロダクションビルド

## 重要な注意事項

1. **日本語対応**: すべてのUIテキストは日本語で記述
2. **アクセシビリティ**: ARIAラベルとセマンティックHTMLを使用
3. **レスポンシブ対応**: モバイルとデスクトップの両方に対応
4. **型安全性**: TypeScriptの厳格モードを維持

## 今後の開発時の確認事項

新機能を追加する際は、以下を確認してください：

1. 既存のコードパターンに従っているか
2. 適切なテストが追加されているか
3. TypeScriptの型が正しく定義されているか
4. コミットメッセージがConventional Commits形式か
5. 日本語UIテキストが適切か
6. レスポンシブデザインが維持されているか
7. パフォーマンスへの影響を考慮したか

## 今後の開発予定

### 未実装機能・改善項目

以下の機能は今後実装予定です（優先度順）：

1. **オンライン対戦機能**

   - WebSocketを使用したリアルタイム対戦
   - ルーム作成・参加機能
   - 観戦モード

2. **AIの強化**

   - より高度な評価関数の実装
   - 機械学習モデルの導入検討
   - 思考過程の可視化

3. **統計・分析機能**

   - 対戦履歴の保存
   - 勝率・統計情報の表示
   - 棋譜の保存・読み込み

4. **UI/UXの改善**

   - アニメーションの追加
   - サウンドエフェクト
   - テーマカスタマイズ機能

5. **チュートリアルの拡充**
   - インタラクティブなチュートリアル
   - 戦略解説の追加
   - 練習問題モード

### GitHub Projects/Issues連携

- 新機能の実装時は必ずGitHub Issueを作成
- 進捗はGitHub Projectsで管理
- PRには関連するIssue番号を記載

## Git操作のベストプラクティス

### Git Flow開発フロー

このプロジェクトでは**Git Flow**に従って開発を行う：

1. **ブランチ戦略**

   - `main`: 本番環境用（リリース済みのコード）
   - `develop`: 開発環境用（次回リリース予定のコード）
   - `feature/機能名`: 新機能開発用ブランチ
   - `bugfix/バグ名`: バグ修正用ブランチ
   - `hotfix/修正名`: 緊急修正用ブランチ

2. **開発フロー**

   - 新機能開発: `develop`から`feature/`ブランチを作成
   - バグ修正: `develop`から`bugfix/`ブランチを作成
   - 作業完了後: PRを作成してdevelopにマージ
   - developマージ後: ステージング環境で動作確認
   - リリース時: developからmainにマージ

3. **ブランチ命名規則**
   - `feature/issue-番号-簡潔な説明` (例: `feature/9-online-multiplayer`)
   - `bugfix/issue-番号-簡潔な説明` (例: `bugfix/5-white-text-fix`)
   - `hotfix/緊急度-簡潔な説明` (例: `hotfix/critical-security-fix`)

### コミットの粒度

- **適切な粒度でコミットを区切る**
  - 1つのコミットには1つの論理的な変更のみを含める
  - 機能追加、バグ修正、リファクタリングを混在させない
  - レビューしやすい単位でコミットする

### 静的テストの実行

- **コミット前に必ず静的テストを実行**
  - `npm run lint` - ESLintでコード品質チェック
  - `npm run typecheck` - TypeScriptの型チェック（該当する場合）
  - `npm test` - ユニットテストの実行
  - すべてのテストがパスすることを確認してからコミット

### コミット前チェックリスト

1. 不要なconsole.logやデバッグコードを削除したか
2. コードフォーマットを適用したか（`npm run format`）
3. 静的テストがすべてパスしたか
4. コミットメッセージはConventional Commits形式か
5. 関連する変更がすべて含まれているか

### Issue管理のルール

1. **Issueのステータス管理**

   - 作業開始前: **必ずIssueをIn Progressに設定**
   - PR作成時: **IssueをIn Reviewに変更**
   - 実装完了後も**勝手にIssueをクローズしない**
   - レビュー承認後、マージ時にIssueをクローズ

2. **Issue対応の正しい流れ**

   - 作業開始: `gh issue edit [番号] --add-label "in progress"`でステータス変更
   - 実装作業: featureブランチで開発
   - 実装完了: Issueにコメントで実装内容とコミット番号を記載
   - PR作成: Issue番号を含むPRを作成
   - レビュー待ち: `gh issue edit [番号] --remove-label "in progress" --add-label "in review"`でステータス変更
   - マージ完了: PRマージ時に自動的にIssueクローズ（`Fixes #番号`使用）

3. **GitHub Projects連携**
   - 可能な場合はGitHub Projectsでカンバン管理
   - To Do → In Progress → In Review → Doneの流れ
   - **注意**: 現在のリポジトリには `in progress` や `in review` ラベルが存在しない
   - ラベルがない場合は、コメントで状態を明示（例：「作業開始しました」「PR #XX を作成しました。レビューをお願いします」）
